# CI/CD

## 概要
この章では、CI/CDについて理解し、現在のCloud Nativeの実環境でなぜ利用されているか、そしてなぜ必要かを説明します。
現在、Continuous Delivery Fundation (https://cd.foundation/) が設立され、CI/CDのベストプラクティスなど業界仕様をさらに推進しています。

***
### CI/CDとは  
---
CI/CDについてですが、 **CI** は、(**Continuous Integration：継続的なインテグレーション**)の略称で、  
開発者がアプリケーション開発から統合(Intergration)まで、必要なプロセスを自動化します。  
開発プロセスとして、ソースコード取得、ビルト、ソースコード取得、アプリケーションの統合、  
パッケージング、単体・結合テストなどを実施します。  

**CD**は、(**Continuous Delivery: 継続的デリバリー**)の略称で、アプリケーションのリリースまでの自動化を担います。    
また、CDとしては、(Continuous Deploy: 継続的デプロイ)として意味合いも持ちます。  
その違いの棲み分けとしては、責任範囲の違いにあります。   
継続デリバリーは、上記の通り、アプリケーションのリリースまで自動化しますが、  
ユーザが機能を利用可能な状態までにはしません。CIで作成されたアプリケーションやマニフェストなどの  
資産を自動的に本番環境に公開可能な上状態まで運びます。

継続デプロイは、デプロイまでの自動化を担い、対象ソフトウェアを本番環境にデプロイした後、  
ユーザへの公開も自動的に行います。そして、ソフトウェアの有効性をテストし、条件を満たせば  
定められたタイミングユーザ公開をし、条件を満たせなければロールバックし、デプロイ前の状態に復旧する責任を持ちます。  

![image](image/cicd_pic.jpg)
---
### なぜCI/CDが必要になるのか・・・
---
アプリケーションのマイクロサービス化が主流になっている中、CI/CDはマイクロサービス・アジャイル開発が  
登場する以前から存在した概念であり、CI/CD注目度、重要度が上がってきています。    
なぜならソフトウェアデリバリプロセスに対して、人の手が都度介入しなければならないデリバリプロセスには、  
コンテナイメージビルド、バリでション、テスト、デプロイ、ローンチがあり、あらゆる局面での品質やリードタイムに  
ばらつきを産む可能性があり、その点をCI/CDを使うことにより、「徹底的な自動化」をデリバリプロセスに提供することから、   
品質を一定に保つことが可能になります。  

最近では、Cloud Native環境においては、Gitopsを利用したKubernetesへのアプリケーションデプロイが  
増えてきており、例えば、GitHub ActionsなどのCIツールとCD部分を専用としてOSSであるArgoCDと  
組み合わせた利用事例が増えています。ArgoCDが多く利用される理由としては、GUIを通して設定が可能であり、  
且つステータスの確認やSync状況などを確認できる優位性があるためです。  

## GitHub Actionsを使ったCI体験

この章では、GitHub Actionsを使って継続的インテグレーション(CI)の実践的な体験を行います。GitHub Actionsはコードリポジトリと密接に統合されています。様々なイベント（プッシュ、プルリクエスト作成など）をトリガーにワークフローを実行できるため、開発プロセスの自動化に非常に便利なツールです。


### 準備：サンプルアプリケーションのフォーク

以下のリポジトリをフォークして、ハンズオンの準備をします：

```bash
# 以下のURLにアクセスしてリポジトリをフォーク
https://github.com/cloudnativedaysjp/cnd-handson-app
```

フォークが完了したら、ローカル環境にクローンします：

```bash
git clone https://github.com/<あなたのGitHubユーザー名>/cnd-handson-app.git
cd cnd-handson-app
```

### CIパイプラインの構造

フォークしたリポジトリには、以下のCIパイプラインが設定されています：

1. **コードチェック**: コードの品質チェック（lint, format）
2. **テスト**: 単体テストと統合テスト
3. **ビルド**: アプリケーションのビルドとコンテナイメージの作成

これらは全てGitHub Actionsのワークフローとして定義されており、`.github/workflows/`ディレクトリに配置されています。

## Lintとフォーマットチェック

### Lintとは

Lintツールは、コード内の潜在的なエラー、バグ、スタイルの問題、疑わしい構造などを検出するためのツールです。コードの品質を向上させ、バグを減らすために使われます。

### フォーマットチェックとは

コードフォーマッターは、コードを一貫したスタイルで書くことを強制するツールです。チーム内でコーディングスタイルを統一し、読みやすさと保守性を高めるために使用されます。

### 最適な実施タイミング

Lintとフォーマットチェックは以下のタイミングで実行すると効果的です：

1. **ローカル開発中**: 開発者が自分のマシンでコードを書いている最中にlinterやformatterを適用する
2. **コミット前**: Git hooks（pre-commit）を使って、問題のあるコードがリポジトリに入るのを防ぐ
3. **CIパイプラインの初期段階**: プッシュやプルリクエスト作成時に自動的に実行

早い段階でこれらのチェックを行うことで、問題を早期に発見し、修正コストを低減できます。

### 実践：Lint

ローカルで開発中やコミット前にチェックすることが一般的ですが、このハンズオンではサンプルアプリケーションにLintエラーを含むコードを追加、プッシュしてGitHub Actionsがどのように動作するかを確認します。


1. `fronend/Error.js`というファイルを作成して以下のコードを追加します：

```jsx
// TODO: Lintエラーを含むサンプルコードを追記
```

2. 変更をコミットしてプッシュします：

```bash
git add .
git commit -m "Add component with lint errors"
git push origin main
```

3. GitHub上でリポジトリのActionsタブを開き、ワークフローの実行結果を確認します。
   Lintチェックが失敗しているはずです。

4. エラーメッセージを確認し、どのような問題が検出されたのか理解しましょう。

5. 問題を修正したコードを作成し、再度プッシュして成功するか確認します：

```jsx
// TODO: Lintチェックが成功するサンプルコードを追記
```

### Lintとフォーマットのまとめ

- Lintとフォーマットチェックは、コード品質を維持するための重要
- 早い段階で実施することで、問題の発見と修正のコストを低減
- チーム開発において、コードの一貫性と品質を保つ
- CIパイプラインの最初の防衛線として機能

## テスト

### テストの種類と役割

ソフトウェアテストには様々な種類、例えば以下のようなテストがあります：

1. **単体テスト**: 個々の機能やメソッドが正しく動作するかをテスト
2. **統合テスト**: 複数のコンポーネントが連携して正しく動作するかをテスト
3. **エンドツーエンドテスト**: ユーザーの視点からシステム全体の動作をテスト

### 最適な実施タイミング

1. **開発の早期段階**: コード実装と並行して早い段階でテストを書くことで、設計の問題を早期に発見できる
2. **コード変更後**: 新機能の追加や既存コードの修正後に実行し、リグレッションを防止する
3. **CIパイプライン内**: コードがマージされる前に自動的に実行し、問題のある変更が本流に入るのを防ぐ

### 実践：テスト

1. アプリケーションに新しい機能を追加し、対応するテストを意図的に失敗させます：

```javascript
// TODO: テストが失敗するサンプルコードを追記
```

2. そして、対応するテストファイルを作成します：

```javascript
// TODO: テストが失敗するサンプルコードを追記
```

3. 変更をコミットしてプッシュします：

```bash
git add .
git commit -m "Add calculator functionality with failing test"
git push origin main
```

4. GitHub上でActionsタブを開き、テストが失敗することを確認します。

5. 実装を修正し、テストが成功するようにします：

```javascript
// TODO: テストが成功するサンプルコードを追記
```

6. 修正をコミットしてプッシュします：

```bash
git add .
git commit -m "Fix calculator implementation"
git push origin main
```

7. テストが成功することを確認します。

### テストのまとめ

- テストは品質保証の基盤であり、バグの早期発見に役立つ
- 自動テストにより、繰り返し実行可能で一貫性のある検証が可能になる
- CIパイプラインでのテスト自動化により、問題のあるコードがプロダクションに到達する前に検出できる

## ビルドとコンテナイメージの作成

CIの最終段階として、アプリケーションをビルドし、コンテナイメージを作成するプロセスがあります。このステップが成功すると、Argo CDなどのCDツールによって後続のデプロイプロセスで使用できる準備が整います。

### アプリケーションのビルド

アプリケーションのビルドステップでは、依存関係のインストール、コードの最適化、静的ファイルの生成などが行われます。

```bash
# 例：Reactアプリケーションのビルド
npm ci  # クリーンインストール
npm run build
```

### コンテナイメージの作成

Docker イメージの作成は、アプリケーションを動作環境に依存せず実行できるようにするための重要なステップです。GitHub Actionsを使って、コンテナイメージを自動的に作成し、コンテナレジストリに公開することができます。


（時間があれば各自のリポジトリのpackagesへdockerイメージをpushするコンテンツを追加）

## まとめ

この章では、CI(継続的インテグレーション)の基本概念と、GitHub Actionsを使った実践的な実装方法を学びました。重要ポイントを押さえておきましょう：

1. CIは開発フローを自動化し、品質を向上させるための重要な手法
2. Lintとフォーマットチェックは、早期にコード品質の問題を発見するのに役立つ
3. 自動テストは、バグの早期発見と修正に貢献し、安定したソフトウェアの提供を支援する
4. コンテナ化により、一貫性のある環境でアプリケーションのビルドと実行が可能になる

